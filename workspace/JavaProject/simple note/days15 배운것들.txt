day 15

'상속' 시작


Extends01 (상속)

- 클래스의 상속이란?
1차목적, 2차목적

- 클래스를 상속하는 방법


Extends02 (01과 묶어)

- 또다른 예시
- 상속을 받는 클래스, 상속을 하는 클래스의 명칭들


Extends03

- 부모클래스의 멤버변수에 접근지정자가 있으면? 접근이 가능한가?
public, protected, default, private


(04, 05 생성자 호출 규칙)
Extends04 - 실행해보고 결과를 통해 어떤 생성자가 먼저 호출되는지 보자

- 부모 클래스를 상속받은 클래스의 생성자는 어디서 호출되는거지?
 객체 생성 과정

- super();는 생략가능

- 자식 생성자가 오버로딩 된 경우!

호출시 super로 부모생성자를 먼저 호출


Extends05

- 이번에는 반대로 부모 생성자에 매개변수가 있는 경우!
super(); 명령이 감춰지지 않아야하며, 꼭 써야하는 경우이다.

-> 해결방법
1. 자식 클래스에 super(전달인자); or this(전달인자); 를 넣는다.
2. 부모 클래스에 디폴트 생성자를 생성한다.


Extends06 (코드블록에 쓰고 생성자의 실행 순서는 어떨까 생각해보는 시간을 가지도록 하자)

- 여기 시험 출제된다!

- 그럼 생성자의 실행 순서는 어떻게 될까? 에 대한 이야기


Extends07 - 메소드 오버라이딩

- 상속 문법 (1~3은 정리) 4번이 오버라이딩이 필요한 이유
- 메소드 오버라이딩 규칙!


Extends08_TypeCasting01 ( 쭉 한번 보고 지나갈 내용이라는데..)

- 객체들간의 Casting은 안된다!


Extends08_TypeCasting02 (실제 사용 예시는 다음주에 보게 될 것!)

- 부모 클래스, 자식 클래스간의 형변환!
- 강제 캐스팅

3번에 쓰여있는 방법을 굳이 알아야할까? 굳이 이렇게까지 사용해야 할까?
다 필요한 때가 있다. 나중에 알게될것.

- instanceof 연산자 : 형변환 가능 여부를 판별하는 방법.




