days125 배운것들


※



우리는 node.js를 통해 http 서버에 연결할거야!!

※ HTTP 서버를 구축하는데, 코드가 지저분하다!
-> Express 로 구축할땐 깔끔해진다!



※ JSON?
 웹에서 쓰는 객체...라고 생각한다. 자세한건 인터넷 검색으로 정리!


※ 작동이 안 된다...
-> 05_Server05.js 한번 확인해...
--> 주석 내가 달아둔게 많아서 복붙하지 말고 쭉 확인해야 할 것이다.
---> GET, POST 부분의 /users 를 확인해보자
----> 혹은 Front.html 한번 보고...script 태그 내부가 잘못된 것 같은데?
- 해결! url이 /users 인데 /user로 보내고 있었다.


※ html 버튼 만들었는데 글자가 안 보인다...



※ 등록 버튼을 눌렀는데 NOT FOUND 로 넘어간다...
POST 의 /users 에서 어디 return이 안 되나?
어디선가 문제가 생긴듯...


===> 위 두 문제....때문에 05 복붙 해야하나





05_Server05.js
days 124 에 이어서 웹 페이지를 제작한다.
-> 어제 했던 내용을 다시 한번 더 하고 05 나머지 스타트
===================================

※ localhost는 127.0.0.1 과 같다! 즉, 내 컴퓨터의 서버와 같다!
따라서 내 컴퓨터 내부의 서버를 부를땐

localhost:8090 이렇게 써도 좋고, 127.0.0.1:8090 으로 쓴다!


-> .createServer 안의 익명함수
==> 클라이언트에서 현재 서버로 요청이 들어오면 실행되는 익명함수.

-> .listen 안의 익명함수
==> 서버가 처음 실행되어서 대기상태로 갈떄 한번 실행되는 익명함수, 생략 가능하다.



--> 05_Front.html의 파일을 웹에 보여주고싶다...
--> 파일을 읽기 위해 fs 모듈을 promise로 불러와야 한다.
--> 그리고 fs.readFile로 05_Front.html을 읽어온다.
--> 읽은 내용을 넣기 위해서는 .then 으로 받아서 익명함수를 쓰겠지만, await를 이용해 변수에 넣는 방식으로 깔끔하게 바꾼다.
--> await를 쓰면? await가 있는 함수를 async로 묶고, try~catch로 묶어야한다.
--> 여기까지 하면 해당 html을 읽어올 수 있다.


※ 다만 단순하게 한번 보여주고 끝! 이런 페이지가 아니야! 다른 페이지로도 보내고 해당 페이지에서 멤버를 추가해서 보여주는 등의 동작도 할거야!

- 이전에 스프링에서 mapping 하듯, url에 따른 동작을 if~else if 문으로 분리시킨다.

-> 그리고 GET 에서 url이 / 일때, /about 일때를 만든다!

--> 05_Front.html, 05_about.html 제작
--> Home 버튼을 누르면 홈 페이지로, About 버튼을 누르면 다른 페이지로 넘어간다.



※ 내가 원하는 url 이 05_Server.js에 없을 경우?
아무 일도 일어나지 않고, 처리도 안 된다. catch에서는 404 에러를 잡아서 띄우지 않기 때문이다.

-> 따라서 함수 내의 try에 404 에러가 떴다는 내용을 출력하도록 만든다. 그리고 각 url의 end를 return을 해주도록 만든다.

§ 이렇게 만드는 이유?
1. catch에서는 404 에러를 잡지 않는다.
2. 마지막에 else 로 만들어도 좋아 보이지만, 이 경우에는 GET 방식이던 POST 방식이던 하나에 걸려서 들어가면 해당 else문을 실행하지 않기 때문이다.
3. 각 url에서 return을 해주는 이유는 return으로 함수를 끝내지 않으면 404 에러로 만든 함수가 무조건 실행되기 때문이다.




※ 05_Front.html 에 주목!
- 일반적으로 form의 submit 은 전송 -> 처리 -> 새로운페이지 로딩 의 과정을 거치면서 화면전환이 일어난다.
- 다만 이번에는 화면전환 없이 전송->처리->현재위치 로 복귀하기 위해 자바스크립트의 이벤트 리스너와 axios 객체를 이용하여 등록을 처리한다.


- 이벤트 리스너 사용하기
-> form이 submit 되는 때를 잡아서 실행될 이벤트리스너 설정!

--> axios를 이용하여 server로 요청을 보낸다.
--> axios는 비동기이므로 순서대로 동작하게 하도록 await, try~catch, async를 추가한다.

※ axios 특성상 서버에서 보내오는 응답은 현재의 위치로 응답되어져 복귀한다. 만약 돌아오는 값이 있다면 변수에 값을 넣어주어야 한다.



※ html에서 요청 시작!

- html에서 조회를 요청 -> Server.js의 req에 요청 도착 -> Server.js의 POST의 url이 /user인 곳에 요청이 도착
-> 이후 동작은 주석과 함께 확인해

--> 넘어온 데이터를 받아서 user라는 변수에 id라는 key로 넘어온 value를 저장한다.

---> 그리고 다시 원래 자리로 복귀.



※ 다시 05_Front.html 에 돌아와서
- getUsers() 함수를 이용해 <div id="list"></div> 부분에 저장된 user 리스트를 조회하고 나열하도록 만든다.
-> script 태그 안에 getUsers() 함수 생성

--> axios 객체를 이용하여 get 방식으로 url /users에 요청
--> get 메서드 방식의 /users 요청, 결과 형식은 json 형식이다.
--> 비동기를 동기처럼 사용하기 위해 await 추가 + 값을 리턴받아서 써야하므로 변수에 저장


---> Server에서도 GET에 해당 url 제작

----> html에서는 Server에서의 리턴값을 변수에 받고, 다시 요청에 대한 반환(리턴) 값을 객체형식으로 변환(키:값)한다.


-----> 다시 Server의 GET - /users에서
-----> 이미 저장되어있는 users 객체 안의 내용을 json 형식으로 변경하여 전송

=> JSON.stringify : 자바스크립트의 값을 JSON 문자열로 변환한다.


------> 다시 html getUsers로 와서
------> users 변수에 있는 키값들을 전달인수로 하여 키값 갯수만큼 반복실행한다.
=> map() : 반복실행의 내장함수
------> 그리고 반복실행 할 때마다 div, span 태그를 생성, span 태그에 key 값으로 얻은 value를 삽입, 그리고 div 태그 안에 span 태그 삽입, list 태그 안에 div 태그를 삽입하도록 한다!




수정 삭제 기능
=====================
- 이제는 front 페이지에 표시되는 아이디를 수정 또는 삭제 가능하도록 만들 예정이다.
-> id가 list 인 div 태그에 삽입할 떄 버튼도 삽입하도록 만든다.

--> span 태그를 만들고 그 안에 값을 넣은 다음, 그 다음에 수정버튼을 생성하게 만든다.

---> 그리고 버튼을 누르면 실행될 수 있도록 이벤트리스너를 만들고, 그 안에 익명함수로 axios를 이용하여 각각 Server에 put, delete method로 보낸다. url 주소는 /user/

----> Server.js에서는 수정, 삭제 행동을 하도록 한다.
----> PUT, DELETE 에서 url 주소 /user/ 작성

-----> 여기서 split을 통해 넘어오는 주소의 뒤에 붙는 숫자를 떼내고 key 값으로 사용한다.









06_Cookie_Server01.js
==============================================
Nodejs에서의 쿠키는 조금 다르다.
request의 모든 요청에 header의 쿠키가 자동으로 동봉된다!

Nodejs에서의 쿠키는 Tomcat Server보다 중요하다!


- 쿠키 내용 주석으로 정리됨





06_Cookie_Server02.js
============================================
서버를 만들고 쿠키를 사용하는 예시를 보여준다. 전달되는 쿼리를 받아서 가공하고 이를 이용하여 로그인하는 동작을 만든다.


- 요청을 받을때마다 쿠키를 얻어낼 수 있다.
- 다만 요청마다 키값, 밸류값을 따로 얻기 위해서는 가공을 해야한다. 별도로 이걸 따로 떼주는 함수는 없다...


-> 전달된 쿠키 객체에서 각 쿠키들은 키:밸류 로 전부 가공해서 객체 형식으로 변환 후 cookies 변수에 저장하려 한다.
-> 이때, js 상단에 직접 만든 parseCookies라는 함수를 이용해서 이를 객체 형식으로 변환한다.


--> paresCookie(req.headers.cookie); 에서 req.headers.cookie는...
--> const parseCookies = (cookie)=>{}; 의 cookie 에 들어간다.

---> 전달된 쿠키를 가공하여 객체 형태로 리턴해주는 parseCookies 함수를 제작한다.
---> 주석 참고




- 웹에 처음 출력할 페이지인 06_Cookie_page.html 를 제작한다.
-> 간단히 로그인 하는 페이지이다.




- 다시 Server로 돌아와서
-> 전달되는 url에 따라 동작을 하도록 if~else로 이를 구분한다.
--> 다만, '/'가 쓰일곳이 많아 주의!


※ /login 에는 startsWith 인 이유는?
 로그인 할 때 전송되는 내용은 /login?name=홍길동 뭐 이런식이라 /login 으로 시작하는 경우를 걸러내는 것이다.

- /login 에서
->  url과 함께 전달되는 name이라는 이름의 query를 분리한다. 분리한 내용을 사용할 것이다.

--> http://127.0.0.1:8090/login?name=홍길동 에서 'name=홍길동' 을 분리해서 query라는 변수에 저장!

---> 그리고 1분 뒤에 사라지는 쿠키를 생성한다.

----> 그리고 res.writeHead 를 이용해 Location으로 설정한 경로로 제작한 쿠키에 이름과 유효시간을 저장해서 response 해준다.

-----> 그리고 url이 /login인 곳에 else if로 cookies.name이 존재하는 경우, 즉 로그인이 되어 현재 name 세션값이 존재하는 경우 cookies가 가진 name 값을 출력하도록 만든다.







06_Session_Server.js
===================================
이번에는 서버에서 세션을 이용해볼 것이다.
이번에는 로그인 내용을 쿠키가 아니라 세션에 저장할 것이다.


- 앞선 06_Cookie_Server02.js 에서 만든것처럼 parseCookies 함수를 만들고, createServer로 서버를 만든다.

-> name을 똑같이 받아오지만, 고유 키값을 Date를 이용해 숫자로 받아온다.
-> 이러면 키값이 숫자가 되어 세션의 밸류값이 노출은 되지만 쿠키에 저장된 밸류값을 알 수 없게 된다.

