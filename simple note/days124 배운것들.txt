day124 배운것들

※ 터미널 cmd 에서 출력하기
해당 폴더로 넘어가기 : cd xxxx
상위 폴더로 넘어가기 : cd ..
nodejs로 실행하기 : node 파일이름






03_OS.js - 운영체제와 관련된 Module을 require 할 것이다.
(언젠가는 쓰게 될 내용이다)
============================================
- 자바에서 import 해서 쓰던 클래스를, 자바스크립트에서는 Module 을 require 한다고 표현한다.


-> 아래는 node.js에 내장된 os에 관련된 module을 쓰기 위해 require 하는 코드이다.
const os = require('os');
-> 기존에 있던 module 이던, 내가 만들던, 내가 가져와서 쓴다!
-> 마치 자바에서 클래스를 만들고 가져다 쓰는 것 처럼..



- os와 관련된 명령들





이번에는 내가 모듈을 만들어서 export 한 뒤, 이것을 require 해볼 것이다.
02 폴더 아래에 03_UserModule 폴더 생성
Var.js
======================================
※ 03_OS.js에서 봤던것처럼, node.js에 내장되어있는 'os' 모듈을 require 해서 그 내부의 변수나 함수를 사용할 수 있었다면, 이번엔 내가 만든 객체를 export 해두고서 이를 require 해서 사용하는 예를 살펴볼 예정이다.


module.exports = { odd:odd, even:even, };
- 두개의 변수를 하나의 객체에 넣고 exports 한 것이다.
-> 그리고 이를 하단 터미널 cmd에서 실행시킨다.
--> 이러면 파일 이름(Var) 으로 exports 된다!
---> 이를 사용하는 예시를 func01.js 파일에서 확인한다.



func01.js
==========================
- const value = require('./Var'); 로 방금 exports 한 Var를 require 하고 console에 출력해본다.

{ odd: '홀수입니다.', even: '짝수입니다.' } 가 나온다.


func02.js
===================================
require 된 객체를 객체분리 시켜보았다.


func03.js
- 여기서는 함수를 exports 하는 것도 들어있다.
=====================================
이번엔 require 자체를 구조분해 시켜보았다.
- require 하는 단계에서 구조를 분해하였다.

- 그리고 require 한 객체를 사용하는 함수를 만들고, 이를 exports 해보았다. 그리고 이 함수를 다른 파일(index.js)에서 require 해서 사용할것이다.


index.js
======================================
- 앞서 exports 한 var와 func03를 require 해서 사용하였다.






다시 02_Internal_Module 에서 작업한다.
04_Path.js - path 모듈
=======================================
- Path 라는 Module 은 경로와 관련된 module이다.
- path는 경로와 파일 관련 모듈이다.


#1. path 가 아니어도 사용 가능한 경로와 파일 관련 상수
console.log(__filename); : 현재 사용중인 파일의 이름
console.log(__dirname); : 현재 파일이 위치한 경로

-> 굉장히 많이 쓰이는 키워드라고 한다!




#2. path를 사용하는 것들

path.seq : 경로 내부의 폴더들 구분 문자 출력 -  \(백슬래쉬)
path.delimiter : 환경변수 내에서 서로 다른 경로를 같이 나타낼때 구분해주는 구분 문자 출력 - ;

path.dirname() : 파일이 위치한 폴더 경로를 보여준다.
path.extname() : 파일의 확장자(.js)를 보여준다.
path.basename() : 파일의 이름+확장자를 보여준다.
path.basename(extname 제외) : 이건.....?

path.parse() : 파일의 경로를 root, dir, base, ext, name으로 분리한다.
path.format() : 파일의 경로와 이름, 확장자를 제공하고, 경로-파일이름-확장자로 조합한다.
path.normalize() : 파일 경로를 사용하던 중 \ 나 / 를 실수로 여러번 쓴것을 수정한다.


path.isAbsolute(C:\\) : 파일의 경로가 절대 경로인지 상대경로인지 true false 로 표시한다. 
해당 예시는 true 출력
path.relative('C:\\TIL\\nodejs', 'C:\\') : 인수로 나오는 경로와 경로 사이에 이동 경로를 표시한다.
해당 예시는 ..\.. 즉, 세번 부모 폴더로 이동했다고 출력
path.join(__dirname, '..', '/TIL', '.', 'node_js') : 처음 경로부터 이후 나오는 경로로 이동한 폴더를 표시한다.
path.resolve(__dirname, '..', '/TIL', '.', 'node_js') : resolve 와 join 은 비슷하지만, '/' 표시를 절대경로인지, 상대경로인지 어떻게 보는지가 다르다.








05_Url.js
==========================================
- 이번엔 Url 이라는 Module 에 대해 학습한다.


-> 주어지는 url 주소를 분해...파싱해서 나열해준다.
-> 인터넷 주소를 parse 함수로 분해해서 각각의 요소들을 따로 분리하고 사용할 수 있다.

--> url.parse 로 query와 pathname 을 파싱해서 얻을 수 있다는 것을 알아두자. 나중에 이러한 정보들을 사용해야 할 경우가 생길수도 있다.

--> console.log(parsedUrl.query); 이렇게 parsedUrl 로 파싱한 내용중에 query 만 출력하도록 만든다!

---> 자바에서 request.getParameter로 파라미터를 받듯이, 여기도 이런 방식으로 파라미터를 받는 것이다!
그래서 중요한것!





06_readFile.js
==============================================
- fs 라는 모듈은 파일 읽기 쓰기를 위한 모듈이다.

- 우선 같은 폴더 안에 readMe.txt 파일을 제작하고, 아무 정보나 써둔다.
-> 그리고 이 파일에 읽기 쓰기를 할 것이다.


fs.readFile(경로, 옵션) : 파일을 읽어온다. 옵션 부분에는 함수나 문자열 등이 들어간다.




07_readFilePromise.js
============================================
※ 에러가 발생하면 throw err; 로 끝내도록 했다. 다만 이렇게 하면 이후 작업들이 전부 멈춰버린다!
자바에서는 Exception 처리로 이를 방지했으나, 자바스크립트에서는 비동기 방식으로 이를 처리한다.

- Promise 는 비동기 실행이므로, 아래의 명령이 나중에 실행되도록 뒤에 기술하여도 실행속도가 빠른 명령은 먼저 실행 후, promise 결과가 출력된다.









08_WriteMe.js
============================================
이번에는 파일에 쓰기를 한다.

- writeFile(경로, 쓸 내용, 옵션) : 파일에 쓰기 동작을 한다. 옵션에는 함수나 문자열 등이 들어간다.

-> writeMe.txt 파일을 명령을 통해 생성하였다!




09_WriteAndRead.js (연습)
============================================
wirteem2.txt 에 '안녕하세요, 반갑습니다!' 를 쓰고, 바로 읽어서 콘솔창에 출력하는 연습을 하였다.






10_WriteFilePromise.js
=================================================
- Promise를 이용해서 파일 쓰기 동작을 하는 방법이다.









01_Basic 폴더에 추가한다.
08_anotherPromise.js (이 학습을 하나 빼먹었다고 한다.)
===============================================
- Promise 결과를 별도의 함수 안에서 활용할때 많이 사용하는 방법을 학습한다.


-> 결과를 함수 안에서 쓰기 위해서는 promise에 await가 들어간다.
-> 단, await 를 사용한 명령은 반드시 async 로 함들어진 함수 안에서 사용해야한다.
-> 또한 try ~ catch로 감싸주어야 한다!


※ 결론
 async, await, try~catch 이 셋은 묶어서 외워야 한다!
항상 같이 다니는 그룹이다!



- 동기식 실행이 필요한 경우...
- await promise의 연속 실행





다시 02_Internal_Module 폴더에 만든다.
11_readFileAsync.js
==========================================
우선 실습을 위한 파일을 만든다.
- readMe1.txt, readMe2.txt, readMe3.txt 파일을 02 폴더에 만든다.
-> 그리고 각각의 txt 파일에 서로 다른 글을 써둔다.

--> fs 자체는 비동기이다. 따라서 그냥 따로 작성하면 그 순서가 뒤죽박죽 나온다.

---> 차례대로 동작하게 하고싶다?
아예 하나의 비동기 함수 실행영역 안에 또 다른 비동기 함수를 넣어, 하나의 동작이 끝나면 뒤 이어서 동작하도록 하나에다가 몰아넣으면 된다!






12_ReadFileAsyncPromise.js
==========================================
- 파일을 읽는 동작도 순서대로 만들 수 있다!
-> 파일에 예시





§ 여기까지가 기본적으로 사용되는 문법들이다...
이 다음에는 HTTP Server를 어떻게 node.js로 만드는지 확인한다.
서버를 세우고, 브라우저로 주소를 쳐서 들어가본다!







03_HttpServer 폴더를 만든다.
서버를 구축할 수 있는 코드를 담은 자바스크립트 코드를 만들 것이다!

01_Server01.js
==========================================
- Node.js에 포함된 기능과 문법을 이용해서 웹 호스팅을 할 수 있는 서버를 구축한다.

-> 내장된 모듈 중에 http 모듈을 이용한다!

--> createServer(익명함수) 함수 : Node.js 자바스크립트로 만든 http 서버가 실행되게 하는 함수이다.

※ (req, res)=>{ } : 서버에 클라이언트가 요청이 있을 때 실행할 명령들이 들어간다.
.listen( 8090, ()=>{} ) 에 있는 ()=>{} 는 서버가 시작되면 실행할 명령이 들어간다.

※ req는 요청을 받고, res는 응답을 해준다.



- 이제 터미널 창에 node 01_Server01.js 명령을 한다! 그럼 서버가 실행된다.
그리고 크롬에 localhost:8090을 써보자
그럼 내가 response로 보낸 내용이 화면에 출력된다!

-> 실행시킨 서버를 종료시키고 싶다면 터미털 cmd 창에 ctrl+c 키를 누르자.







02_Server02.js
===============================================
- 이번에는 서버 기능을 실행시키면서 에러가 나면 에러처리를 할 수 있도록 만들었다.






03_Server03.js
============================================
- 이번에는 서버를 한번에 여러개를 실행해보았다.

※ res.end(내용) : 실행 후에는 더이상 응답 내용이 전송될 수 없다.

#1. createServer를 여러번 호출하는 방식으로 여러 서버를 실행시킬 수있다!
-> 단, 두 서버의 포트를 다르게 지정해야한다. 포트번호가 충돌하면 에러가 발생한다.





04_Server04.js
===============================================
※ 앞서 01_Basic의 07_Promise와 08_anotherPromise를 다시 학습해보자

- 이번에는 보내줄 내용을 내가 써서 보내는게 아니라 파일에 있는 내용을 보내도록 만들것이다!

- 04_Server.html을 제작한다.
 서버를 열고 위의 html을 보내 웹에 띄울것이다!


- 파일을 그냥 보내는 방식이 아니라 파일을 열어서 읽어낸 내용을 res.write로 보낸다...
-> 뭔가 번거롭다...


- http 상태 코드
-> 주석으로 정리함







05_Server05.js (사진 찍어!!!)
- 유저를 등록하고 뭐 그런 사이트를 만들어본다.
-> 다만 DB를 이용하지 않고 배열에다가 저장하는 방식으로...
--> 물론 이 방식으로는 서버가 종료될 때 까지만 저장되는 데이터가 된다.
---
===============================================
이번에는 서버를 구축하면서, 요청되는 url에 따라 다른 페이지로 이동하도록 만든다!
마치 쇼핑몰에서 첫 페이지는 main 페이지로 가고, 상품 리스트 페이지를 누르면 상품 리스트에 가는 것 처럼....


- 첫 if문으로 request가 GET, POST, PUT, DELETE 방식으로 들어오는것을 구분시킨다.

- 두번째 if문으로 웹에 어떤 파일을 읽어서 전송할지 선택한다!
ex) GET 방식으로 url 이 '/' 이라면 '05_Front.html' 파일을 읽어다가 웹 페이지에 출력하도록 만든다!


- catch의 경우 서버 실행상의 에러만 잡는다. mapping을 통해 갔는데 mapping이 없거나 jsp가 없는 경우 뜨는 404 에러는 잡지 않는다!
-> 따라서 try 부분에 404 에러가 발생시 실행될 코드를 제작하고, 각 req.url 에 return으로 함수를 끝낼 수 있도록 만든다!

--> return으로 끝내지 않으면 아래에 404 에러를 위해 만든 코드가 무조건 실행되기 때문이다!

---> 그리고 메인 페이지로 띄울 05_Front.html을 만든다.

----> 그리고 서버 실행시 제작한 메인 페이지가 나온다!


※ 05_Front.html에 아래 코드를 추가한다.
<script src="https://unpkg.com/axios/dist/axios.min.js"></script>

-> ajax처럼 페이지 전환 없이 웹을 사용할 수 있는 라이브러리이다.
-> 설명은 주석 참고



- 05_Front.html 에서...
form 태그에 action이 없다...!
-> form의 순수한 submit 이벤트를 이용한다면, 페이지 전환이 일어난다.
-> 페이지 전환없이 등록 절차 실행후 현재 위치로 되돌아오기 위해 axios 객체를 이용한다.
-> submit 버튼이 클릭되는 이벤트를 자바스크립트의 이벤트로 처리하고, axios 객체가 유저 등록 절차를 실행한다.

--> 하단에 script 추가

※ addEventListener : 클릭 또는 더블클릭 또는 현재의 form 태그에서 있을 수 있는 submit 같은 이벤트가 발생하면, 전달인수로 전달된 익명함수를 실행해주는 함수(전달인수 : 이벤트 이름과 익명함수를 함께 전달해준다).

preventDefault() : 폼의 이벤트 동작(submit)이 계속 진행되면 화면 전환이 일어나므로, 이벤트 동작(submit)이 멈춘다.

----> 즉, 정상적인 submit 동작을 멈추게 하고 다른 동작을 하게 만드는 것이다.