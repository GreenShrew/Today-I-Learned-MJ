days132 배운것들 영상 있는데 소리 녹음 안 되었을수도...
사진은 있다. 근데 로그인 기능부터 에러가 발생해서 사진을 못 찍었다.


layout.html부터 시작

※ join.html 복붙해..
※ localStategy.js를 찾을 수 없다고 나오는데...?
-> app.js와 passport 폴더의 index.js에서 문제가 발생한다고 나온다.



npm14
=====================================
어제 만든 layout.html 을 extend 해서 쓸 것이다.
-> 다른 html에서 layout.html의 내용을 가져와서 쓴다. 
-> layout.html을 사용하는 다른 html은, {% block content %}과 {% endblock %} 사이에 들어갈 내용을 만든다!
--> 또한, layout.html에 {% block script %}와 {% endblock %}를 만들어 다른 html에서 script를 작성할 수 있도록 만든다.


--> views 폴더에 메인페이지인 main.html을 만든다.
--> main.html에서도 {% block content %}과 {% endblock %} 사이에 내용을 작성한다!
--> 그리고 main.html에서도 {% block script %}와 {% endblock %} 사이에 내용을 작성한다!
--> 그럼 layout.html에 main.html의 내용이 나온다!




- 이제 page.js로 간다.
-> app.js에서 첫 페이지를 page.js로 잡았다.(url이 / 이면 page.js 로 가도록 만들었다)

--> '/' 요청을 만든다. 메인 페이지로 보낸다. 
--> title과 유저 정보, 그리고 계산이 되어져서 갈 followerCount, followingCount, 그리고 팔로우한 사람들을 담아서 갈 followerIdList, 게시글인 posts 를 같이 보낸다.

---> 그러고 서버를 실행시켜보면 사진01처럼 로그인 화면이 나온다.



- css 적용
-> public 폴더에 main.css 파일 생성
--> 사진 02가 된다.



- 회원가입 기능을 만들것이다.
-> page.js에 '/join' 라우터를 만든다.
--> join.html 을 만든다. 역시 layout.html을 export 한다.

---> 이를 만들고 main 페이지에서 회원가입 버튼을 누르면 사진03처럼 아래에 새로운 박스가 나온다!

----> 이제 회원가입 버튼을 누르면 action이 /auth/join 에 post 방식이다.
----> auth.js에 가서 /join 이라는 라우터를 만든다.
----> join.html에서 emai, nick, password를 가져와서 이를 이용한다.

-----> auth.js의 /join 라우터에서 만약 이미 회원가입된 이메일이라면, join.html로 되돌아가서 '이미 존재하는 이메일입니다'를 출력하고 '/' 라우터로 보내게 만든다.

-----> 만약 회원가입 성공시, auth.js에서 레코드에 추가를 할 것이다.
-----> 다만, 이번에는 암호화모듈인 bcrypt를 사용한다.
const hash = await bcrypt.hash(password, 12);
비밀번호를 1234로 했더니..
$2b$12$kA3xH4MM0c5WeBhg9JYeLuT4YtJZU30fNKie83XOvWDNd/8nxSdhG
뭐 이런 결과가 나온다!
※ 따라서 비밀번호 컬럼의 길이를 설정할 때 좀 넉넉하게 해두어야 한다!


※ hash 연산의 뜻 : 암호화와 비슷한 연산의 결과로, 같은 원본 데이터라도 연산결과가 절대 같은 결과가 나오지 않게 하는 연산.
예를들어, 3 사람의 비밀번호가 1234라도, 해쉬화가 되면 3인의 해쉬 암호는 셋이 전부 다르다.


------> 사진 04 처럼 레코드에 추가된 비밀번호가 암호화된것을 확인할 수 있다.






- 이번에는 로그인 기능을 만든다
-> session-cookie를 이용하여 로그인 정보를 저장한다. 그리고 passport 모듈을 사용하여 로그인을 구현한다.

--> auth.js 의 /login 라우터로 이동한다.
--> 여기서 라우터를 만드는데, 그 안에 있는 미들웨어 내부에다가 또 미들웨어를 제작한다!

---> 여기서 로그인을 위해서 현재 미들웨어가 실행되면, 'local'까지만 인식되고, passport 폴더의 localStategy 라는 곳으로 이동해서 로그인을 처리한다.

---> passport 폴더에 localStategy.js 파일을 만든다.
---> 그리고 일반 사용자의 로그인 절차를 정의한 strategy 를 만든다.
※ 주의점을 주석으로 달아두었다.
---> localStategy.js 에서는 로그인 여부를 확인하고, 로그인 성공&실패 여부 확인 뒤 localStrategy.js 가 호출된 위치의 익명함수로 이동한다. (이때 로그인 성공 실패에 관한 정보와 메세지 등을 가지고 이동한다.)


----> 다시 auth.js 로 돌아온다.
----> 'local'까지만 실행되고 localStategy.js로 이동한뒤, 거기서 done()에 의해 되돌아왔다!


-----> 이제 로그인이 정상 실행되면 세션에 아이디를 저장하는 동작을 한다.
-----> passport 폴더에 index.js 파일을 만든다. 여기에서 세션에 아이디만 저장하는 동작을 만든다.


------> 이제 app.js에서 passport 설정을 해준다.

const passportConfig = require('./passport');
passportConfig();
app.use(passport.initialize());
app.use(passport.session());




- 포스팅 기능
-main.html의 block content에 내용을 넣는다.
※ 여기서 type이 file인 input 태그는 css에 의해 none으로 숨어있지만, 이 태그의 기능이 위의 label 태그와 합쳐져있다.

-> 사진 업로드
-> 사진 선택시 id가 img인 태그의 내용이 변경된다. 이를 이용하여 변경된 사진을 화면에 띄울 것이다.
-> 하단의 block script에 스크립트를 만든다.
-> 해당 스크립트에서는 사진 데이터를 img라는 이름으로 formData에 append 하고, 이를 /post/img 로 post.js에서 /img 주소의 라우터로 보낸다.

--> 이제 post.js에 파일 업로드를 해주는 라우터를 작성한다.
--> /img 라우터를 제작한다.
--> 여기서는 그림만 업로드하고, 그림의 경로를 저장한다.
--> 그리고 저장된 경로를 json 형식으로 되돌려준다.
※ 여기서 url의 경로가 왜 /img 인가? app.js에서 이미지용 스태틱폴더를 별도 생성할때 /img로 설정했기 때문이다. 여기에 맞춰주어야 한다.

app.use('/img', express.static(path.join(__dirname, 'uploads')));

※ 여기서 업로드 한 파일은 img 폴더 안에 저장이 되는데, 그림을 바꾼다고 해당 그림이 지워지는건 아니다...그림은 이미 업로드 되었다!




- 다시 포스팅 기능
- 글 쓰기를 누르면 post 라우터의 /post 로 요청한다.

※ 아래와 같이 none()을 쓰면 업로드를 하지 않는다고 선언하는것이다.
router.get('/', upload2.none(), async(req, res)=>{});
왜 이런 처리를 하는가? main.html에 form에 enctype="multipart/form-data" 가 있어서 submit을 누르면 file이 업로드 된다. 근데 위에서 이미 그림을 선택할때 업로드를 시켰다!
따라서 두번 업로드를 하지 않기 위해 파일을 올리지 않겠다고 선언한 것!




- 이번에는 페이지로 갈 때 게시물(포스팅) 리스트를 화면에 표시되도록 만들 것이다.
-> page.js에서 아까 만들었던 '/' 요청으로 간다. '/' 요청을 받아 화면으로 갈 때마다 내용을 검색해서 보낼 것이다!
--> findAll을 이용하여 User 모델의 id, nick이 포함된 포스트를 검색해서 posts에 저장하여 보낸다!

---> 이제 보내진 내용을 웹에 표시한다. main.html에 class 명이 twits인 div 태그를 만들고, 그 안에 반복실행을 통해 포스팅 내용이 추가되도록 한다.
---> 아이디, 닉네임, 그리고 이미지가 있다면 이미지, 내용을 표시하게 한다.



- 그리고 auth.js에 로그아웃 기능을 위한 /logout 요청의 라우터를 만든다.



- 내 정보를 열람할 수 있는 프로필 기능을 만든다.
-> page.js에 /profile 라우터를 만든다.
-> 여기서는 정보를 DB에서 긁어서 profile.html로 넘긴다.

--> 그리고 profile.html을 만든다.
--> 참고로 이 시점에서 user.Followings, user.Followers는 안 나올 것이다. 아직 구현하지 않았기 때문!




- 포스팅시 해쉬태그를 저장할 수 있는 기능을 제작한다.
-> main.html에 태그 검색창을 제작한다.

--> 해쉬태그는 포스팅 될 때 해쉬태그 테이블에 레코드가 들어간다.
--> post.js에서 게시물을 등록하는 post 형식의 '/' 요청 라우터에서, redirect를 하기 전에 해쉬태그를 추가하도록 한다.

---> 여기서 문장이 여럿 있는데, 이를 찾는 방법으로는 '정규표현식'이 있다.
---> 정규 표현식은 문자열에서 특정 문자의 조합을 찾기 위한 패턴이다.

ex) var a = '안녕하세요 반갑습니다. 이것은 신발입니다. 신발이 참 예쁘네요! #신발 #예쁜신발 #많이파세요'
이런식으로 저장이 되어있다고 가정하자. 여기서 #으로 시작해서 ' '(띄어쓰기) 로 끝나는 문장을 찾으면 '#신발' '#예쁜신발' '#많이파세요'가 된다. 이렇게 특정 문자의 조합을 찾는것을 말한다.

var b = a.match(/#[^\s#]*/g);	\는 백슬래쉬...
-> '#'으로 시작해서 빈칸과 '#'이 아닌 곳 까지를 단어로 해서 모두 검색

이렇게 만들고 b를 출력해보면 
#신발, #예쁜신발, #많이파세요 가 골라진다!


----> 위의 정규표현식으로 내용 안에서 해쉬태그를 뽑아낸다. 해쉬태그가 있다면 게시물이 등록될때 Hashtag 테이블에 레코드를 같이 추가해준다.
----> 예를들어 #사과 라는 해쉬태그가 있는지 테이블을 검색하고, 테이블 내에 없다면, 이를 생성해준다.
----> 만약 #사과 라는 해쉬태그가 이미 존재한다면 Hashtag 테이블에 추가하지는 않는다.
----> 그러고나서 이를 태그와 게시물을 연결해주어야 하는데, Sequelize가 이를 자동으로 연결해준다!
----> 이전에 posthashtag 이라는 이름으로 테이블을 만들도록 했는데, 여기에 자동으로 Hashtag의 테이블과 Post 테이블을 연결해준다!
ex) 1번 게시물에 1번 태그, 1번 게시물에 2번 태그
 2번 게시물에 2번 태그
이런식으로....




- 해쉬태그를 이용한 검색 기능을 만든다.
-> main.html에 태그 검색창을 제작한다.(위에서 이미 작업함)
-> 검색을 누르면 /hashtag로 요청한다.

--> page.js에 해당 라우터를 만든다.

---> 넘어온 검색어가 있는지 확인하고
---> 없으면 메인으로
---> 있으면 해시태그 단어를 검색하고, 검색된 해시태그를 이용해 외래키 관계로 연결된 게시물을 검색한다.
---> 그리고 검색된 게시물을 main.js로 보낸다.




