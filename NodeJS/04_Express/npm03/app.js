const express = require('express');
const path = require('path');

const app = express();
app.set('port', process.env.PORT || 3000);
// app.get() 또는 app.post() 등... 리퀘스트로 키워드를 받아 해당 요청에 응답을 보내주는 메서드들을 "라우터(Router)" 라고 부른다. 첫번째 매개변수 전달요소별로 리퀘스트 키워드를 요청받아 익명함수를 실행해서 응답한다. 그 메서드 안에 들어가는 익명함수들 ()=>{} 을 "미들웨어" 라고 부른다.


// 미들웨어만을 위한 멤버함수(라우터)가 존재한다.
// 1. 모든 라우터들이 실행되기 전 실행되는 라우터 : 보통 다른 라우터들의 위쪽에 기술되어져서, 모든 라우터들이 실행되기 전 실행의 대상으로 인식된다.
// 아래의 라우터는 다른 라우터들이 요청될 때 한번 실행된다.
app.use((req, res, next)=>{
    console.log('모든 요청에 실행하고 싶어요');
    next();
    // 모든 라우터에 next 가 있지만 사용하지 않아서 생략된 상태이다. 필요하면 꺼내서 쓸 수 있다.
    // next() 가 없으면 현재 라우터에서 요청에 대한 응답이 종료될 수 있으니, 미들웨어를 위한 라우터는 반드시 next() 을 사용해주자!
    // next() 가 없다면, 이 라우터가 실행 한 뒤에 실행이 종료되어 버린다.
    // 따라서 요청된 url에 따른 라우터가 실행되지 않는다!
});
// ------------------------------------------------------------------


// 2. 특정 request 키워드에서만 실행할 미들웨어
app.use('/about', (req, res, next)=>{   // '/about' 요청이 들어올때만 실행되는 라우터이다!
    console.log('about 요청에만 실행하고 싶어요');
    next();
});
// get과 post 등 모든 method 에서 리퀘스트 키워드만 같으면 실행된다.
// 실행 후 next로 인해 제어권이 아래로 이동하여, 해당 get이나 post 등이 추가 실행된다.
// ------------------------------------------------------------------
app.get('/about', (req, res)=>{
    res.send('<h2>Hello, About</h2>');
});



// 4.1 에러발생 ----------------------------------------------(없어도 되는데 에러를 만들려고 만듬)
app.use((req, res, next)=>{ // 혹시라도 중간에 에러가 나는 경우
    // throw new Error("서버-에러를 발생시켜주마!!");  // 에러 강제 발생, 주석 풀고 확인해봐.
    // 파일 맨 아래에 4.2 에러 처리 라우터가 없으면 브라우져에 에러 내역이 표시되어 모든 서버 구조가 노출된다(500 에러)
    // 에러 내역은 서버의 콘솔에만 나오고, 브라우져에는 에러처리에 의한 내용만 나오도록 "에러 처리 라우터"를 마지막에 추가해준다.

    // 5. 에러 처리의 또다른 형태
    /*
    try{
        console.log(정의안된변수사용);  // 에러 만들기
    }catch(error){
        next(error);    // 에러 처리 미들웨어로 이동하라는 next
        // next에 error가 인수로 들어가면 에러처리 라우터로 이동한다.
        // error 말고 'router' 가 인수이면 다음 미들웨어로 이동하라는 뜻
    }
    */
    next();
});




// 이 get 하나가 하나의 라우터이다. 그리고 라우터는 익명함수, 즉, 미들웨어를 품고 있다.
app.get('/', (req, res)=>{
    res.sendFile(path.join(__dirname,'/index.html'));
});

app.get('/abc', (req, res)=>{
    res.sendFile(path.join(__dirname,'/index1.html'));
});



// 7. 리퀘스트 키워드의 와일드카드 문자
app.get('/category/Boots', (req, res)=>{
    res.send('<h2>Hello Boots</h2>');
});
app.get('/category/Heel', (req, res)=>{
    res.send('<h2>Hello Heel</h2>');
});
// 와일드 카드 키워드를 사용한 라우터는 범위가 넓다.
// 따라서 가능한 아래쪽에 위치시켜서, 명확한 구분은 먼저 실행되게 하고
// 해당 라우터가 없을 때 실행되게 하는것이 효과적이다.
// 와일드카드가 포함된 라우터를 위에 위치하면 위에 쓰인 Boots, Heel 로 가는 명령에는 도달하지 못 하게 된다.
app.get('/category/:name', (req, res)=>{    // :name 안에 변수들이 들어간다.
    res.send(`<h2>Hello Wild Card Char ${req.params.name}</h2>`);
});

// 위의 Boots, Heel의 경우 각각 Hello Boots 와 같은 내용을 출력하지만,
// http://localhost:3000/category/sandal 와 같이 정의되지 않은 url으로 갔을 때, 위와 같은 와일드카드를 사용한 라우터가 있다면 실행된다.
// 요청을 받는 라우터나 페이지가 없다고 404 에러가 나오는게 아니다!
// -----------------------------------------------------------








// 6. 404 에러 처리
app.use((req, res, next)=>{
    res.send('비정상적 접근! 에러입니다!');
    // res.status(404).send('404 에러!');   이렇게 알려줄 수 있지만 그냥 감추는게 정답이다.
    // 400 에러와 500 에러는 위험하다.
    // 계속 해당 에러를 일으키면 서버가 맛이 가거나 하기 때문이다! DDOS 공격의 기초!
});




// 4.2 에러 처리 라우터 --------------------------------------
// 위쪽 라우터 또는 미들웨어에서 에러가 발생했을 때 실행되는 미들웨어이다.
// 에러 처리 라우터에 있는 미들웨어는 반드시 매개 변수가 err, req, res, next 네개가 쓰여져야 에러처리로 인식된다.. 넷중에 하나만 빠져도 에러 처리 라우터로 인식되지 못 한다!
// listen 전에 해당 에러처리를 만드는게 국룰

app.use((err, req, res, next)=>{
    console.error(err);
    res.status(200).send('에러내용을 브라우저에 알려주지 않겠다!');
});


app.listen(app.get('port'), ()=>{
    console.log(app.get('port'), '3000번 포트에서 대기중입니다.')
});



// 8. 미들웨어의 특성
// 하나의 미들웨어에서 res.send() 또는 res.sendFile() 등을 두번 이상 쓸 수 없다. res.json() 도 예외는 아니다.
// http 서버에서 사용하던 res.writeHeader() + res.end() 가 합쳐져서 res.send() 가 된 것이므로 위 send를 두번 이상 쓰는건 의도치 않은 에러를 발생한다.
// res.json() 또한 그렇다.
// res.writeHeader(200, {'Content-Type':'application/json'});
// res.end(FJSON.stringify({hello:'hong'}));
// 위 둘이 합쳐져서 res.json({hello:'hong'}); 으로 사용된다.
// 역시 다른 메서드들과 함께 두번 이상 사용하지 않는다.

// Express 서버의 다른 서버와의 특징
// http 모듈의 웹 서버의 확장판으로 코드의 가독성이 좋고 확장성이 좋다.
// 프레임이 잡혀있어 파일 관리 및 운영이 용이하다.
// 비슷한 서버로서 Koa, Hapi 등이 있지만, Express 서버를 가장 많이 사용한다.
// 코드 관리 및 편의성에서 많은 장점을 제공한다.

// package.json
// Express 서버의 초기 설정 값들을 넣고 조절하는 파일이다.
// 직접 작성하여 파일을 생성해도 되고, npm init를 실행하여 생성하여도 무방하다.